name: üöÄ Deploy to Production

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/digitalboda-backend

jobs:
  security-scan:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: üì¶ Checkout code
      uses: actions/checkout@v4

    - name: üîç Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: üìä Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  test:
    name: üß™ Run Full Test Suite
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: test_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
      
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - name: üì¶ Checkout code
      uses: actions/checkout@v4

    - name: üêç Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.12'
        cache: 'pip'

    - name: üìã Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install coverage pytest-django

    - name: üîß Set up test environment
      run: |
        # Generate proper Fernet key for testing
        python -c "from cryptography.fernet import Fernet; print('ID_ENCRYPTION_KEY=' + Fernet.generate_key().decode())" > .env
        # Create .env file for testing
        cat >> .env << EOF
        SECRET_KEY=test-secret-key-for-ci
        DEBUG=True
        DJANGO_ENV=testing
        DB_NAME=test_db
        DB_USER=postgres
        DB_PASSWORD=postgres
        DB_HOST=localhost
        DB_PORT=5432
        ALLOWED_HOSTS=localhost,127.0.0.1
        ID_HASH_SALT=test-salt
        EOF

    - name: üóÉÔ∏è Run migrations
      run: |
        python manage.py migrate

    - name: üß™ Run tests with coverage
      run: |
        coverage run --source='.' manage.py test
        coverage report --show-missing
        coverage xml

    - name: üìä Upload coverage reports
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella

    - name: üìä Check code style and security
      run: |
        pip install flake8 bandit safety
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics
        bandit -r . -x tests/ -f json -o bandit-report.json || true
        safety check --json --output safety-report.json || true

  build-and-deploy:
    name: üèóÔ∏è Build and Deploy to Production
    needs: [security-scan, test]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event.inputs.force_deploy == 'true')
    environment: production

    steps:
    - name: üì¶ Checkout code
      uses: actions/checkout@v4

    - name: üîê Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: üè∑Ô∏è Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-
          type=raw,value=latest

    - name: üèóÔ∏è Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

    - name: üì¶ Create deployment package
      run: |
        tar -czf deployment.tar.gz \
          docker-compose.production.yml \
          nginx.conf \
          .env.example

    - name: üöÄ Deploy to Digital Ocean Production
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.PRODUCTION_HOST }}
        username: ${{ secrets.PRODUCTION_USER }}
        key: ${{ secrets.PRODUCTION_SSH_KEY }}
        port: ${{ secrets.PRODUCTION_PORT }}
        script: |
          # Create backup of current deployment
          cd /var/www/digitalboda_production
          
          # Backup database
          docker-compose -f docker-compose.production.yml exec -T db pg_dump -U $DB_USER $DB_NAME > backup_$(date +%Y%m%d_%H%M%S).sql
          
          # Pull latest changes
          git fetch origin
          git checkout main
          git pull origin main
          
          # Update environment variables (ensure they exist)
          if [ ! -f .env.production ]; then
            echo "Error: .env.production file not found!"
            exit 1
          fi
          
          # Build and restart containers with zero-downtime deployment
          docker-compose -f docker-compose.production.yml pull
          docker-compose -f docker-compose.production.yml up --build -d --no-deps web
          
          # Wait for health check
          sleep 30
          
          # Run migrations
          docker-compose -f docker-compose.production.yml exec -T web python manage.py migrate
          
          # Collect static files
          docker-compose -f docker-compose.production.yml exec -T web python manage.py collectstatic --noinput
          
          # Restart all services
          docker-compose -f docker-compose.production.yml restart
          
          # Check container health
          docker-compose -f docker-compose.production.yml ps
          
          # Verify deployment
          curl -f http://localhost:8000/admin/ || exit 1

    - name: üîî Notify deployment status
      if: always() && secrets.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          üöÄ Production Deployment ${{ job.status }}!
          Branch: ${{ github.ref_name }}
          Commit: ${{ github.sha }}
          Author: ${{ github.actor }}
          Environment: Production
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

    - name: üè∑Ô∏è Create Release
      if: success()
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: v${{ github.run_number }}
        release_name: Release v${{ github.run_number }}
        body: |
          üöÄ Production deployment successful!
          
          **Changes in this release:**
          ${{ github.event.head_commit.message }}
          
          **Deployed at:** ${{ github.event.head_commit.timestamp }}
          **Commit:** ${{ github.sha }}
        draft: false
        prerelease: false
